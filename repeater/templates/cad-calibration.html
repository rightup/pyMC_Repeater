<!DOCTYPE html>
<html>
<head>
    <title>pyMC Repeater - CAD Calibration</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="/static/style.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-chart-matrix@2.0.1/dist/chartjs-chart-matrix.min.js"></script>
    <style>
        .calibration-controls {
            background: var(--bg-secondary);
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            border: 1px solid var(--border-color);
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .control-group label {
            font-weight: 600;
            color: var(--text-secondary);
        }
        
        .control-group input {
            padding: 8px 12px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background: var(--bg-primary);
            color: var(--text-primary);
            width: 80px;
        }
        
        .buttons {
            display: flex;
            gap: 10px;
            margin-left: auto;
        }
        
        .chart-container {
            background: var(--bg-secondary);
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            border: 1px solid var(--border-color);
            height: 500px;
            position: relative;
        }
        
        .status-container {
            background: var(--bg-secondary);
            border-radius: 8px;
            padding: 15px;
            margin: 20px 0;
            border: 1px solid var(--border-color);
        }
        
        .progress-container {
            margin-top: 15px;
        }
        
        .progress-bar {
            width: 100%;
            height: 8px;
            background: var(--bg-tertiary);
            border-radius: 4px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent), var(--primary));
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 4px;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .stat-card {
            background: var(--bg-tertiary);
            border-radius: 6px;
            padding: 15px;
            text-align: center;
            border: 1px solid var(--border-color);
        }
        
        .stat-value {
            font-size: 1.5em;
            font-weight: bold;
            color: var(--primary);
            margin-bottom: 5px;
        }
        
        .stat-label {
            color: var(--text-secondary);
            font-size: 0.9em;
        }
        
        .results-container {
            background: var(--bg-secondary);
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            border: 1px solid var(--border-color);
        }
        
        .best-result {
            background: var(--success-bg);
            border: 2px solid var(--success);
            border-radius: 6px;
            padding: 15px;
            margin-top: 15px;
            color: var(--success-text);
        }
        
        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Include navigation -->
        <nav class="nav-container">
            <div class="nav-brand">
                <a href="/" class="nav-link">
                    <i class="nav-icon">ðŸ“¡</i>
                    <span>{{ node_name }}</span>
                </a>
            </div>
            <div class="nav-links">
                <a href="/" class="nav-link">Dashboard</a>
                <a href="/configuration" class="nav-link">Configuration</a>
                <a href="/cad-calibration" class="nav-link active">CAD Calibration</a>
            </div>
        </nav>

        <div class="content">
            <div class="page-header">
                <h1>CAD Calibration Tool</h1>
                <p>Real-time Channel Activity Detection calibration with heatmap visualization</p>
            </div>

            <!-- Controls -->
            <div class="calibration-controls">
                <div class="control-group">
                    <label for="samples">Samples per test:</label>
                    <input type="number" id="samples" value="50" min="10" max="200">
                </div>
                <div class="control-group">
                    <label for="delay">Delay (ms):</label>
                    <input type="number" id="delay" value="100" min="50" max="500">
                </div>
                <div class="buttons">
                    <button id="start-btn" class="btn btn-primary">Start Calibration</button>
                    <button id="stop-btn" class="btn btn-danger" disabled>Stop</button>
                </div>
            </div>

            <!-- Status and Progress -->
            <div class="status-container">
                <div id="status-message">Ready to start calibration</div>
                <div class="progress-container">
                    <div class="progress-bar">
                        <div id="progress-fill" class="progress-fill"></div>
                    </div>
                    <div id="progress-text">0 / 0 tests completed</div>
                </div>
            </div>

            <!-- Statistics -->
            <div class="stats-grid">
                <div class="stat-card">
                    <div id="tests-completed" class="stat-value">0</div>
                    <div class="stat-label">Tests Completed</div>
                </div>
                <div class="stat-card">
                    <div id="best-rate" class="stat-value">0%</div>
                    <div class="stat-label">Best Detection Rate</div>
                </div>
                <div class="stat-card">
                    <div id="avg-rate" class="stat-value">0%</div>
                    <div class="stat-label">Average Rate</div>
                </div>
                <div class="stat-card">
                    <div id="elapsed-time" class="stat-value">0s</div>
                    <div class="stat-label">Elapsed Time</div>
                </div>
            </div>

            <!-- Chart -->
            <div class="chart-container">
                <canvas id="heatmapChart"></canvas>
            </div>

            <!-- Results -->
            <div id="results-container" class="results-container hidden">
                <h3>Calibration Results</h3>
                <div id="best-result" class="best-result hidden">
                    <h4>Optimal Settings Found:</h4>
                    <p id="best-settings"></p>
                </div>
            </div>
        </div>
    </div>

    <script>
        let eventSource = null;
        let heatmapChart = null;
        let isRunning = false;
        let startTime = null;
        let calibrationData = {};
        let peakRange = [];
        let minRange = [];

        // Initialize Chart.js heatmap
        function initChart() {
            const ctx = document.getElementById('heatmapChart').getContext('2d');
            
            heatmapChart = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [{
                        label: 'Detection Rate (%)',
                        data: [],
                        backgroundColor: function(context) {
                            const value = context.parsed.v || 0;
                            return getHeatmapColor(value);
                        },
                        pointRadius: function(context) {
                            const canvas = context.chart.canvas;
                            const width = canvas.width;
                            const height = canvas.height;
                            return Math.min(width, height) / 50; // Adjust based on canvas size
                        },
                        pointHoverRadius: function(context) {
                            const canvas = context.chart.canvas;
                            const width = canvas.width;
                            const height = canvas.height;
                            return Math.min(width, height) / 40;
                        }
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                title: function(context) {
                                    const point = context[0];
                                    return `Peak: ${point.parsed.x}, Min: ${point.parsed.y}`;
                                },
                                label: function(context) {
                                    return `Detection Rate: ${context.parsed.v.toFixed(1)}%`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            position: 'bottom',
                            title: {
                                display: true,
                                text: 'CAD Peak Threshold'
                            },
                            grid: {
                                display: true
                            }
                        },
                        y: {
                            type: 'linear',
                            title: {
                                display: true,
                                text: 'CAD Min Threshold'
                            },
                            grid: {
                                display: true
                            }
                        }
                    },
                    onHover: function(event, activeElements) {
                        event.native.target.style.cursor = activeElements.length > 0 ? 'pointer' : 'default';
                    }
                }
            });
        }

        // Color mapping for heatmap
        function getHeatmapColor(value) {
            if (value >= 80) return '#4CAF50';  // Green - Excellent
            if (value >= 60) return '#8BC34A';  // Light Green - Good
            if (value >= 40) return '#FFC107';  // Yellow - Moderate
            if (value >= 20) return '#FF9800';  // Orange - Poor
            if (value > 0) return '#F44336';    // Red - Very poor
            return '#9E9E9E';                   // Gray - No data
        }

        // Update chart with new data
        function updateChart(peak, min, rate) {
            if (!heatmapChart) return;
            
            const dataPoint = {
                x: peak,
                y: min,
                v: rate
            };
            
            heatmapChart.data.datasets[0].data.push(dataPoint);
            heatmapChart.update('none'); // No animation for real-time updates
        }

        // Start calibration
        async function startCalibration() {
            const samples = parseInt(document.getElementById('samples').value);
            const delay = parseInt(document.getElementById('delay').value);
            
            try {
                const response = await fetch('/api/cad-calibration-start', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ samples, delay_ms: delay })
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const result = await response.json();
                if (result.success) {
                    isRunning = true;
                    startTime = Date.now();
                    calibrationData = {};
                    
                    // Clear chart
                    if (heatmapChart) {
                        heatmapChart.data.datasets[0].data = [];
                        heatmapChart.update();
                    }
                    
                    // Update UI
                    document.getElementById('start-btn').disabled = true;
                    document.getElementById('stop-btn').disabled = false;
                    document.getElementById('results-container').classList.add('hidden');
                    
                    // Start SSE connection
                    connectEventSource();
                } else {
                    showError(result.error || 'Failed to start calibration');
                }
            } catch (error) {
                showError('Failed to start calibration: ' + error.message);
            }
        }

        // Stop calibration
        async function stopCalibration() {
            try {
                const response = await fetch('/api/cad-calibration-stop', {
                    method: 'POST'
                });
                
                if (response.ok) {
                    isRunning = false;
                    document.getElementById('start-btn').disabled = false;
                    document.getElementById('stop-btn').disabled = true;
                    
                    if (eventSource) {
                        eventSource.close();
                        eventSource = null;
                    }
                }
            } catch (error) {
                console.error('Failed to stop calibration:', error);
            }
        }

        // Connect to Server-Sent Events
        function connectEventSource() {
            if (eventSource) {
                eventSource.close();
            }
            
            eventSource = new EventSource('/api/cad-calibration-stream');
            
            eventSource.onmessage = function(event) {
                try {
                    const data = JSON.parse(event.data);
                    handleCalibrationUpdate(data);
                } catch (error) {
                    console.error('Failed to parse SSE data:', error);
                }
            };
            
            eventSource.onerror = function(event) {
                console.error('SSE connection error:', event);
                if (!isRunning) {
                    eventSource.close();
                    eventSource = null;
                }
            };
        }

        // Handle calibration updates
        function handleCalibrationUpdate(data) {
            switch (data.type) {
                case 'status':
                    document.getElementById('status-message').textContent = data.message;
                    break;
                    
                case 'progress':
                    const percent = data.total > 0 ? (data.current / data.total) * 100 : 0;
                    document.getElementById('progress-fill').style.width = percent + '%';
                    document.getElementById('progress-text').textContent = `${data.current} / ${data.total} tests completed`;
                    document.getElementById('tests-completed').textContent = data.current;
                    break;
                    
                case 'result':
                    // Store result and update chart
                    const key = `${data.det_peak}_${data.det_min}`;
                    calibrationData[key] = data;
                    updateChart(data.det_peak, data.det_min, data.detection_rate);
                    updateStats();
                    break;
                    
                case 'complete':
                    isRunning = false;
                    document.getElementById('start-btn').disabled = false;
                    document.getElementById('stop-btn').disabled = true;
                    document.getElementById('status-message').textContent = 'Calibration completed';
                    showResults(data.results);
                    
                    if (eventSource) {
                        eventSource.close();
                        eventSource = null;
                    }
                    break;
                    
                case 'error':
                    showError(data.message);
                    stopCalibration();
                    break;
            }
            
            // Update elapsed time
            if (startTime) {
                const elapsed = Math.floor((Date.now() - startTime) / 1000);
                document.getElementById('elapsed-time').textContent = elapsed + 's';
            }
        }

        // Update statistics
        function updateStats() {
            const rates = Object.values(calibrationData).map(d => d.detection_rate);
            if (rates.length === 0) return;
            
            const bestRate = Math.max(...rates);
            const avgRate = rates.reduce((a, b) => a + b, 0) / rates.length;
            
            document.getElementById('best-rate').textContent = bestRate.toFixed(1) + '%';
            document.getElementById('avg-rate').textContent = avgRate.toFixed(1) + '%';
        }

        // Show results
        function showResults(results) {
            document.getElementById('results-container').classList.remove('hidden');
            
            if (results && results.best) {
                const best = results.best;
                document.getElementById('best-result').classList.remove('hidden');
                document.getElementById('best-settings').innerHTML = 
                    `Peak: <strong>${best.det_peak}</strong>, Min: <strong>${best.det_min}</strong>, Rate: <strong>${best.detection_rate.toFixed(1)}%</strong>`;
            }
        }

        // Show error message
        function showError(message) {
            document.getElementById('status-message').textContent = 'Error: ' + message;
            document.getElementById('status-message').style.color = 'var(--error)';
        }

        // Event listeners
        document.getElementById('start-btn').addEventListener('click', startCalibration);
        document.getElementById('stop-btn').addEventListener('click', stopCalibration);

        // Initialize chart when page loads
        document.addEventListener('DOMContentLoaded', function() {
            initChart();
        });

        // Cleanup on page unload
        window.addEventListener('beforeunload', function() {
            if (eventSource) {
                eventSource.close();
            }
        });
    </script>
</body>
</html>